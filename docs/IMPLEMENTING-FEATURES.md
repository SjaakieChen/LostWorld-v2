# Implementing New Features

This guide walks you through adding new features to the Lost World codebase, ensuring you follow established patterns and maintain code quality.

## Before You Start

1. **Understand the Architecture**: Read `ARCHITECTURE.md` to understand the overall structure
2. **Know the State System**: Review `docs/STATE-MANAGEMENT.md` for state management patterns
3. **Understand Entities**: Check `docs/ENTITY-STORAGE.md` for entity storage patterns
4. **Understand Data Flow**: Read `docs/DATA-FLOW.md` to understand how data moves through the system

## Choosing the Right Context

Before implementing, determine which context your feature needs:

### GameStateContext
**Use when**:
- Feature needs to trigger game generation
- Feature needs game configuration data
- Feature tracks overall game lifecycle

**Example**: Game lifecycle management (save/load is already implemented - see `docs/STATE-MANAGEMENT.md` for details)

### EntityMemoryStorage
**Use when**:
- Feature creates/updates/removes entities
- Feature queries entities by location or ID
- Feature needs to iterate all entities

**Example**: Adding a crafting system that creates new items

### PlayerUIContext
**Use when**:
- Feature affects player's view of the world
- Feature manages player inventory/equipment
- Feature handles player interactions (NPCs, items)
- Feature tracks player position or exploration

**Example**: Adding a quest log UI component

## Component Organization

Components are organized by **feature domain**:

```
src/components/
├── character/          # Character-related UI
├── character-creation/ # Initial setup
├── common/            # Shared across domains
├── game/              # Core game display
└── inventory/         # Inventory management
```

### Where to Place New Components

1. **Feature-specific component**: Create new folder in `components/`
   ```
   components/
   └── quests/          # New feature domain
       ├── QuestLog.tsx
       └── QuestTracker.tsx
   ```

2. **Shared component**: Place in `components/common/`
   ```
   components/
   └── common/
       └── Tooltip.tsx  # Used across multiple features
   ```

3. **Extending existing feature**: Add to existing folder
   ```
   components/
   └── inventory/
       └── CraftingPanel.tsx  # Related to inventory
   ```

## Adding a New Component

### Step 1: Create Component File

```typescript
// src/components/quests/QuestLog.tsx
import { usePlayerUI } from '../../context/PlayerUIContext'
import { useEntityStorage } from '../../context/EntityMemoryStorage'

export default function QuestLog() {
  const { currentLocation } = usePlayerUI()
  const { allItems } = useEntityStorage()
  
  return (
    <div className="quest-log">
      {/* Component implementation */}
    </div>
  )
}
```

### Step 2: Add Required Contexts

Import and use only the contexts you need:

```typescript
// If you need player data
const { currentLocation, playerStats } = usePlayerUI()

// If you need entity data
const { getAllItemById, getEntitiesAt } = useEntityStorage()

// If you need game state
const { gameState, generatedData } = useGameState()
```

### Step 3: Integrate into App

Add component to `App.tsx`:

```typescript
// src/App.tsx
import QuestLog from './components/quests/QuestLog'

function GameUI() {
  // ... existing code ...
  
  return (
    <div className="grid grid-cols-3 gap-4 h-full">
      {/* Existing columns */}
      <QuestLog />  {/* Add here */}
    </div>
  )
}
```

## Extending Entity Types

### Data Flow Considerations

When extending entity types, consider how data flows through the system:

1. **Generation**: If AI-generated, update schema and prompts
2. **Storage**: EntityMemoryStorage automatically handles new fields
3. **Display**: Update EntityModal components if field should be visible
4. **Save/Load**: New fields are automatically saved (no code changes needed)
5. **Validation**: Add validation if field has constraints

### Adding New Fields to Existing Entity

#### Step 1: Update Type Definition

```typescript
// src/types/item.types.ts
import type { GeneratableEntity } from './base.types'

export interface Item extends GeneratableEntity {
  category?: string
  // New field
  questItem?: boolean  // Indicates if item is related to quests
}
```

**Data Flow Impact**: 
- ✅ No breaking changes (optional field)
- ✅ Existing entities continue to work (field undefined)
- ✅ New entities can include field

#### Step 2: Update Entity Generation (if needed)

If the field needs to be generated by AI:

```typescript
// src/services/entity-generation/core.ts
export const ITEM_SCHEMA = {
  type: 'object',
  properties: {
    // ... existing properties ...
    questItem: { type: 'boolean', description: 'Is this item quest-related?' }
  },
  required: ['name', 'rarity', /* ... */]  // questItem is optional
}

// src/services/entity-generation/item-generation.ts
// Update prompt to mention quest items if relevant
```

**Data Flow Impact**:
- Generated entities will include new field
- Existing generation code continues to work
- LLM may or may not set field based on prompt

#### Step 3: Update Components That Use Entity

```typescript
// Component that displays item
const { allItems } = useEntityStorage()

const questItems = allItems.filter(item => item.questItem === true)
```

**Data Flow Impact**:
- Components read from EntityMemoryStorage (no changes needed to storage)
- Filtering happens at component level (derived data)
- No impact on save/load (field automatically included)

**Important**: If adding to `GeneratableEntity`, it applies to Items, NPCs, and Locations. Consider if this makes sense.

**Breaking Change Prevention**:
- ✅ Always add as optional field (`questItem?: boolean`)
- ✅ Don't add to `required` array in schema
- ✅ Components should check for field existence before using

### Adding a New Entity Type

**Rare case** - usually Items, NPCs, Locations, and Regions cover most needs.

#### Step 1: Create Type Definition

```typescript
// src/types/quest.types.ts
export interface Quest {
  id: string
  name: string
  description: string
  status: 'active' | 'completed' | 'failed'
  objectives: QuestObjective[]
  rewardItems: string[]  // Item IDs
}
```

#### Step 2: Add to EntityMemoryStorage

```typescript
// src/context/EntityMemoryStorage.tsx

interface EntityStorageState {
  // ... existing ...
  allQuests: Quest[]  // New registry
}

// Add methods
getAllQuestById: (id: string) => Quest | undefined
addQuest: (quest: Quest) => void
updateQuest: (quest: Quest) => void
```

#### Step 3: Update Spatial Index (if needed)

If quests are location-based:

```typescript
interface CoordinateEntities {
  locations: Location[]
  npcs: NPC[]
  items: Item[]
  quests: Quest[]  // Add if location-based
}
```

**Note**: Most new entity types likely won't need spatial indexing if they're not world-placed entities.

## Extending Contexts

### Adding New State to PlayerUIContext

#### Step 1: Update Interface

```typescript
// src/context/PlayerUIContext.tsx

interface PlayerUIContextType {
  // ... existing state ...
  
  // New state
  activeQuests: Record<string, Quest>
  questHistory: Quest[]
  
  // New actions
  acceptQuest: (questId: string) => void
  completeQuest: (questId: string) => void
}
```

#### Step 2: Add State Variables

```typescript
export const PlayerUIProvider = ({ children }: PlayerUIProviderProps) => {
  // ... existing state ...
  
  const [activeQuests, setActiveQuests] = useState<Record<string, Quest>>({})
  const [questHistory, setQuestHistory] = useState<Quest[]>([])
  
  // ... rest of provider ...
}
```

#### Step 3: Implement Actions

```typescript
const acceptQuest = (questId: string) => {
  const quest = getAllQuestById(questId)
  if (quest) {
    setActiveQuests(prev => ({
      ...prev,
      [questId]: { ...quest, status: 'active' }
    }))
    // Update quest in EntityStorage
    updateQuest({ ...quest, status: 'active' })
  }
}
```

#### Step 4: Add to Context Value

```typescript
return (
  <PlayerUIContext.Provider
    value={{
      // ... existing values ...
      activeQuests,
      questHistory,
      acceptQuest,
      completeQuest
    }}
  >
    {children}
  </PlayerUIContext.Provider>
)
```

## Adding New Services

### Data Flow Integration

Services integrate into the data flow at different points:

1. **Entity Generation Services**: Flow into EntityMemoryStorage
2. **Orchestrator Services**: Flow into GameStateContext
3. **Chatbot Services**: Called directly from components, may use data packages for context
4. **Utility Services**: Called from anywhere that needs them

**Data Packages for LLM Services**: When adding new chatbot/LLM services, check if existing data packages (e.g., `LocalGameContext`) provide the needed context. Reuse existing packages instead of re-parsing data. See `docs/LLMs.md` for comprehensive LLM implementation guide and `docs/SERVICES.md` Data Packages section for details.

### Step 1: Create Service File

```typescript
// src/services/quest/quest-generator.ts

import { getApiKey } from '../../config/gemini.config'

export async function generateQuest(
  prompt: string,
  gameRules: GameRules
): Promise<Quest> {
  // Implementation using Gemini API
  // Return generated quest
}
```

**Data Flow**: 
```
Service generates Quest
    ↓
Returns Quest object
    ↓
Caller (context or component) receives Quest
    ↓
If entity: Add to EntityMemoryStorage
If config: Add to GameStateContext
```

### Step 2: Export from Service Index

```typescript
// src/services/quest/index.ts

export { generateQuest } from './quest-generator'
export type { Quest } from './quest-types'
```

### Step 3: Use in Components/Orchestrator

```typescript
// In orchestrator (for initial generation)
import { generateQuest } from '../services/quest'

const quest = await generateQuest('Create a fetch quest', gameRules)

// If quest is an entity, add to EntityMemoryStorage
addQuest(quest)
```

**Data Flow Integration**:
- Services are stateless (no internal state)
- Services return data, don't store it
- Contexts or components call services and handle storage

## Type Safety

### Always Update Types First

1. **Define types** in `src/types/`
2. **Export from** `src/types/index.ts`
3. **Import in components/services**

### Type Checking

Ensure TypeScript compilation succeeds:

```bash
npm run build
```

This will catch type errors before runtime.

### Common Type Patterns

```typescript
// Entity IDs follow pattern
type ItemId = `ite_${string}_${string}_${string}`

// Slots store IDs
type SlotId = string | null

// Coordinates
interface Coordinates {
  region: string
  x: number
  y: number
}
```

## Testing Considerations

### What to Test

1. **State Updates**: Do entities update correctly in both spatial index and registries?
2. **Context Dependencies**: Does your component work with correct context nesting?
3. **Entity Operations**: Do add/update/remove operations maintain consistency?
4. **Player Actions**: Do player interactions update state correctly?

### Manual Testing Checklist

- [ ] Component renders without errors
- [ ] Context hooks return expected data
- [ ] State updates persist correctly
- [ ] Entity operations maintain spatial index
- [ ] Dev dashboard shows changes (dev mode)
- [ ] TypeScript compilation succeeds

### Testing Entity Updates

```typescript
// Test that spatial index stays consistent
const { addEntity, getEntitiesAt } = useEntityStorage()

const item = createTestItem({ region: 'region_001', x: 10, y: 20 })
addEntity(item, 'item')

const { items } = getEntitiesAt('region_001', 10, 20)
expect(items).toContainEqual(item)  // Should be in spatial index
```

## Integration Points

### Context Provider Order

**Critical**: Providers must nest in this order:

```typescript
<GameStateProvider>
  <EntityStorageProvider>
    <PlayerUIProvider>
      {/* Your components */}
    </PlayerUIProvider>
  </EntityStorageProvider>
</GameStateProvider>
```

### Entity Operations

Always use context methods:

```typescript
// ✅ CORRECT
const { updateEntity } = useEntityStorage()
updateEntity(updatedItem, 'item')

// ❌ WRONG
item.name = 'New Name'  // Direct mutation breaks spatial index
```

### Slot System

Remember slots store IDs:

```typescript
// ✅ CORRECT
inventorySlots['inv_slot_1'] = item.id
const item = getItemInSlot('inv_slot_1')

// ❌ WRONG
inventorySlots['inv_slot_1'] = item  // Don't store objects
```

## Common Implementation Patterns

### Pattern 1: Displaying Entities at Location

```typescript
const { getEntitiesAt } = useEntityStorage()
const { currentLocation } = usePlayerUI()

const { items, npcs } = getEntitiesAt(
  currentLocation.region,
  currentLocation.x,
  currentLocation.y
)

return (
  <div>
    {items.map(item => <ItemCard key={item.id} item={item} />)}
    {npcs.map(npc => <NPCCard key={npc.id} npc={npc} />)}
  </div>
)
```

### Pattern 2: Player Interaction

```typescript
const { takeItem, interactableItems } = usePlayerUI()

function handleTakeItem(item: Item) {
  takeItem(item)  // Handles coordinate update + slot assignment
}
```

### Pattern 3: Updating Entity Attributes

```typescript
const { getAllItemById, updateEntity } = useEntityStorage()

function reduceDurability(itemId: string, damage: number) {
  const item = getAllItemById(itemId)
  if (!item) return
  
  const durability = item.own_attributes?.durability
  if (!durability) return
  
  const updated = {
    ...item,
    own_attributes: {
      ...item.own_attributes,
      durability: {
        ...durability,
        value: Math.max(0, durability.value - damage)
      }
    }
  }
  
  updateEntity(updated, 'item')
}
```

### Pattern 4: Conditionally Rendering Based on State

```typescript
const { gameState } = useGameState()

if (gameState !== 'playing') {
  return <CharacterCreationScreen />
}

return <GameUI />
```

## Debugging Tips

### Check Context Availability

```typescript
try {
  const context = usePlayerUI()
  // Use context
} catch (error) {
  console.error('Context not available - check provider nesting')
}
```

### Inspect State in Dev Dashboard

In dev mode, open dev dashboard (`/dev-dashboard`) to see:
- All entities in storage
- Entity change history
- Current game state
- Player UI state

### Console Logging

```typescript
const { allItems } = useEntityStorage()
console.log('Items in storage:', allItems.length)
console.log('Items at location:', getEntitiesAt(region, x, y))
```

## Checklist for New Features

- [ ] Created component in appropriate folder
- [ ] Used correct context(s)
- [ ] Updated types if adding fields
- [ ] Integrated into App.tsx
- [ ] TypeScript compilation succeeds
- [ ] State updates use context methods
- [ ] Spatial index maintained (if applicable)
- [ ] Dev dashboard shows changes (dev mode)
- [ ] Manual testing completed

## Getting Help

If you're stuck:

1. **Review existing patterns**: Look at similar components in the codebase
2. **Check documentation**: Review ARCHITECTURE.md and other docs
3. **Examine context implementations**: See how existing contexts are structured
4. **Test in isolation**: Create a simple test component first

## Data Flow Considerations for New Features

### Where to Hook Into Data Flow

#### Adding Features That Modify Entities

**Flow**:
```
Component Action
    ↓
PlayerUIContext method (if player-facing)
    OR
Direct EntityMemoryStorage call (if system-level)
    ↓
EntityMemoryStorage.updateEntity()
    ├─→ Updates registry
    ├─→ Updates spatial index
    └─→ Broadcasts change (dev mode)
    ↓
Components re-render with updated data
```

**Implementation**:
- Use existing context methods when possible
- Add new methods to context if needed
- Always maintain spatial index consistency

#### Adding Features That Display Data

**Flow**:
```
Component renders
    ↓
Calls context hook (usePlayerUI, useEntityStorage, etc.)
    ↓
Context computes/retrieves data
    ↓
Component receives data
    ↓
Component renders UI
```

**Implementation**:
- Derive data in render, don't store in component state
- Use context methods for queries
- Memoize expensive computations

#### Adding Features That Generate New Content

**Flow**:
```
User triggers generation
    ↓
Component calls service
    ↓
Service calls LLM API
    ↓
Service returns generated data
    ↓
Component/Context adds to storage
    ├─→ EntityMemoryStorage.addEntity() (if entity)
    └─→ GameStateContext (if config)
    ↓
System indexes/processes new data
    ↓
Components re-render
```

**Implementation**:
- Services handle LLM interaction
- Contexts handle storage
- Components handle UI and user interaction

### Breaking Change Prevention Guidelines

1. **Type Extensions**: Always add optional fields
2. **Method Extensions**: Add new methods, don't change signatures
3. **Context Extensions**: Add new state/actions, don't remove existing
4. **Service Extensions**: Add optional parameters, use overloads
5. **Schema Extensions**: Add optional properties, don't add to required

See `docs/COMMON-PITFALLS.md` for things to avoid, `docs/SERVICES.md` for service layer patterns, and `docs/DATA-FLOW.md` for comprehensive data flow documentation.

