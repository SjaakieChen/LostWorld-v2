# Implementing New Features

This guide walks you through adding new features to the Lost World codebase, ensuring you follow established patterns and maintain code quality.

## Before You Start

1. **Understand the Architecture**: Read `ARCHITECTURE.md` to understand the overall structure
2. **Know the State System**: Review `docs/STATE-MANAGEMENT.md` for state management patterns
3. **Understand Entities**: Check `docs/ENTITY-STORAGE.md` for entity storage patterns
4. **Understand Data Flow**: Read `docs/DATA-FLOW.md` to understand how data moves through the system

## Choosing the Right Context

Before implementing, determine which context your feature needs:

### GameStateContext
**Use when**:
- Feature needs to trigger game generation
- Feature needs game configuration data
- Feature tracks overall game lifecycle

**Example**: Game lifecycle management (save/load is already implemented - see `docs/STATE-MANAGEMENT.md` for details)

### EntityMemoryStorage
**Use when**:
- Feature creates/updates/removes entities
- Feature queries entities by location or ID
- Feature needs to iterate all entities

**Example**: Adding a crafting system that creates new items

### PlayerUIContext
**Use when**:
- Feature affects player's view of the world
- Feature manages player inventory/equipment
- Feature handles player interactions (NPCs, items)
- Feature tracks player position or exploration

**Example**: Adding a quest log UI component

## Component Organization

Components are organized by **feature domain**:

```
src/components/
├── character/          # Character-related UI
├── character-creation/ # Initial setup
├── common/            # Shared across domains
├── game/              # Core game display
└── inventory/         # Inventory management
```

### Where to Place New Components

1. **Feature-specific component**: Create new folder in `components/`
   ```
   components/
   └── quests/          # New feature domain
       ├── QuestLog.tsx
       └── QuestTracker.tsx
   ```

2. **Shared component**: Place in `components/common/`
   ```
   components/
   └── common/
       └── Tooltip.tsx  # Used across multiple features
   ```

3. **Extending existing feature**: Add to existing folder
   ```
   components/
   └── inventory/
       └── CraftingPanel.tsx  # Related to inventory
   ```

## Adding a New Component

### Step 1: Create Component File

```typescript
// src/components/quests/QuestLog.tsx
import { usePlayerUI } from '../../context/PlayerUIContext'
import { useEntityStorage } from '../../context/EntityMemoryStorage'

export default function QuestLog() {
  const { currentLocation } = usePlayerUI()
  const { allItems } = useEntityStorage()
  
  return (
    <div className="quest-log">
      {/* Component implementation */}
    </div>
  )
}
```

### Step 2: Add Required Contexts

Import and use only the contexts you need:

```typescript
// If you need player data
const { currentLocation, playerStats } = usePlayerUI()

// If you need entity data
const { getAllItemById, getEntitiesAt } = useEntityStorage()

// If you need game state
const { gameState, generatedData } = useGameState()
```

### Step 3: Integrate into App

Add component to `App.tsx`:

```typescript
// src/App.tsx
import QuestLog from './components/quests/QuestLog'

function GameUI() {
  // ... existing code ...
  
  return (
    <div className="grid grid-cols-3 gap-4 h-full">
      {/* Existing columns */}
      <QuestLog />  {/* Add here */}
    </div>
  )
}
```

## Extending Entity Types

### Data Flow Considerations

When extending entity types, consider how data flows through the system:

1. **Generation**: If AI-generated, update schema and prompts
2. **Storage**: EntityMemoryStorage automatically handles new fields
3. **Display**: Update EntityModal components if field should be visible
4. **Save/Load**: New fields are automatically saved (no code changes needed)
5. **Validation**: Add validation if field has constraints

### Adding New Fields to Existing Entity

#### Step 1: Update Type Definition

```typescript
// src/types/item.types.ts
import type { GeneratableEntity } from './base.types'

export interface Item extends GeneratableEntity {
  category?: string
  // New field
  questItem?: boolean  // Indicates if item is related to quests
}
```

**Data Flow Impact**: 
- ✅ No breaking changes (optional field)
- ✅ Existing entities continue to work (field undefined)
- ✅ New entities can include field

#### Step 2: Update Entity Generation (if needed)

If the field needs to be generated by AI:

```typescript
// src/services/entity-generation/core.ts
export const ITEM_SCHEMA = {
  type: 'object',
  properties: {
    // ... existing properties ...
    questItem: { type: 'boolean', description: 'Is this item quest-related?' }
  },
  required: ['name', 'rarity', /* ... */]  // questItem is optional
}

// src/services/entity-generation/item-generation.ts
// Update prompt to mention quest items if relevant
```

**Data Flow Impact**:
- Generated entities will include new field
- Existing generation code continues to work
- LLM may or may not set field based on prompt

#### Step 3: Update Components That Use Entity

```typescript
// Component that displays item
const { allItems } = useEntityStorage()

const questItems = allItems.filter(item => item.questItem === true)
```

**Data Flow Impact**:
- Components read from EntityMemoryStorage (no changes needed to storage)
- Filtering happens at component level (derived data)
- No impact on save/load (field automatically included)

**Important**: If adding to `GeneratableEntity`, it applies to Items, NPCs, and Locations. Consider if this makes sense.

**Breaking Change Prevention**:
- ✅ Always add as optional field (`questItem?: boolean`)
- ✅ Don't add to `required` array in schema
- ✅ Components should check for field existence before using

### Adding a New Entity Type

**Rare case** - usually Items, NPCs, Locations, and Regions cover most needs.

#### Step 1: Create Type Definition

```typescript
// src/types/quest.types.ts
export interface Quest {
  id: string
  name: string
  description: string
  status: 'active' | 'completed' | 'failed'
  objectives: QuestObjective[]
  rewardItems: string[]  // Item IDs
}
```

#### Step 2: Add to EntityMemoryStorage

```typescript
// src/context/EntityMemoryStorage.tsx

interface EntityStorageState {
  // ... existing ...
  allQuests: Quest[]  // New registry
}

// Add methods
getAllQuestById: (id: string) => Quest | undefined
addQuest: (quest: Quest) => void
updateQuest: (quest: Quest) => void
```

#### Step 3: Update Spatial Index (if needed)

If quests are location-based:

```typescript
interface CoordinateEntities {
  locations: Location[]
  npcs: NPC[]
  items: Item[]
  quests: Quest[]  // Add if location-based
}
```

**Note**: Most new entity types likely won't need spatial indexing if they're not world-placed entities.

## Extending Contexts

### Adding New State to PlayerUIContext

#### Step 1: Update Interface

```typescript
// src/context/PlayerUIContext.tsx

interface PlayerUIContextType {
  // ... existing state ...
  
  // New state
  activeQuests: Record<string, Quest>
  questHistory: Quest[]
  
  // New actions
  acceptQuest: (questId: string) => void
  completeQuest: (questId: string) => void
}
```

#### Step 2: Add State Variables

```typescript
export const PlayerUIProvider = ({ children }: PlayerUIProviderProps) => {
  // ... existing state ...
  
  const [activeQuests, setActiveQuests] = useState<Record<string, Quest>>({})
  const [questHistory, setQuestHistory] = useState<Quest[]>([])
  
  // ... rest of provider ...
}
```

#### Step 3: Implement Actions

```typescript
const acceptQuest = (questId: string) => {
  const quest = getAllQuestById(questId)
  if (quest) {
    setActiveQuests(prev => ({
      ...prev,
      [questId]: { ...quest, status: 'active' }
    }))
    // Update quest in EntityStorage
    updateQuest({ ...quest, status: 'active' })
  }
}
```

#### Step 4: Add to Context Value

```typescript
return (
  <PlayerUIContext.Provider
    value={{
      // ... existing values ...
      activeQuests,
      questHistory,
      acceptQuest,
      completeQuest
    }}
  >
    {children}
  </PlayerUIContext.Provider>
)
```

## Adding New Services

### Data Flow Integration

Services integrate into the data flow at different points:

1. **Entity Generation Services**: Flow into EntityMemoryStorage
2. **Orchestrator Services**: Flow into GameStateContext
3. **Chatbot Services**: Called directly from components, may use data packages for context
4. **Utility Services**: Called from anywhere that needs them

**Data Packages for LLM Services**: When adding new chatbot/LLM services, check if existing data packages (e.g., `LocalGameContext`) provide the needed context. Reuse existing packages instead of re-parsing data. See `docs/LLMs.md` for comprehensive LLM implementation guide and `docs/SERVICES.md` Data Packages section for details.

### Step 1: Create Service File

```typescript
// src/services/quest/quest-generator.ts

import { getApiKey } from '../../config/gemini.config'

export async function generateQuest(
  prompt: string,
  gameRules: GameRules
): Promise<Quest> {
  // Implementation using Gemini API
  // Return generated quest
}
```

**Data Flow**: 
```
Service generates Quest
    ↓
Returns Quest object
    ↓
Caller (context or component) receives Quest
    ↓
If entity: Add to EntityMemoryStorage
If config: Add to GameStateContext
```

### Step 2: Export from Service Index

```typescript
// src/services/quest/index.ts

export { generateQuest } from './quest-generator'
export type { Quest } from './quest-types'
```

### Step 3: Use in Components/Orchestrator

```typescript
// In orchestrator (for initial generation)
import { generateQuest } from '../services/quest'

const quest = await generateQuest('Create a fetch quest', gameRules)

// If quest is an entity, add to EntityMemoryStorage
addQuest(quest)
```

**Data Flow Integration**:
- Services are stateless (no internal state)
- Services return data, don't store it
- Contexts or components call services and handle storage

## Standard Helper Functions

The codebase provides many standardized helper functions that should be reused to ensure consistency and maintainability. This section documents the most important ones and when to use them.

### Timeline Updates

#### Using logTimelineEvent()

**Location**: `src/services/timeline/timeline-service.ts`

**Purpose**: Standard way to append entries to the timeline with proper turn tracking.

**When to use**: Always use this for timeline updates, never manually manipulate the timeline array.

```typescript
import { logTimelineEvent } from '../services/timeline/timeline-service'

// Standard way to append to timeline
const entry = logTimelineEvent(['user', 'advisorLLM'], userMessage)
// Automatically handles:
// - Turn number from context
// - Unique ID generation
// - Timestamp
// - Timeline context management
```

**Timeline Context Requirements**: 
- Timeline context must be set up (via `pushTimelineContext()` or `generateEntityWithContext()`)
- Turn context must be set up (via `pushTurnContext()` or GameStateContext)
- If context is missing, `logTimelineEvent()` will warn and return null

**Using Context Wrapper**:
```typescript
// In components, use context wrapper when available
const { updateTimeline } = useGameState()
updateTimeline(['user', 'advisorLLM'], userMessage)
// This internally calls logTimelineEvent() with proper context
```

#### Setting Up Timeline Context

**When to set up manually**: Only if you're not using `generateEntityWithContext()` or GameStateContext.

```typescript
import { pushTimelineContext, pushTurnContext } from '../services/timeline/timeline-service'

// Set up timeline context
const releaseTimeline = pushTimelineContext({
  getTimeline: () => gameConfig.theTimeline,
  setTimeline: (updated) => { gameConfig.theTimeline = updated },
  source: 'my-service'  // Optional: for debugging
})

// Set up turn context
const releaseTurn = pushTurnContext({
  getCurrentTurn: () => currentTurn,
  source: 'my-service'  // Optional: for debugging
})

try {
  // Now logTimelineEvent() will work correctly
  logTimelineEvent(['generation'], 'Generated item')
} finally {
  // Always release contexts
  releaseTimeline()
  releaseTurn()
}
```

**Best Practice**: Use `generateEntityWithContext()` for entity generation - it handles timeline context automatically.

### Entity Generation Helpers

#### generateEntityWithContext()

**Location**: `src/services/entity-generation/generation-manager.ts`

**Purpose**: Standard way to generate entities at runtime with automatic timeline and storage integration.

**When to use**: Always use this for runtime entity generation (during gameplay, turn progression, etc.).

```typescript
import { generateEntityWithContext } from '../services/entity-generation/generation-manager'

const result = await generateEntityWithContext({
  type: 'item',  // 'item' | 'npc' | 'location' | 'region'
  prompt: 'Create a legendary fire sword',
  gameRules,
  region: 'region_medieval_kingdom_001',
  x: 45,
  y: -23,
  gameConfig,  // For timeline integration
  entityStorage,  // For automatic storage (optional)
  changeReason: 'Player requested item',  // Optional: why was this created
  onEntityCreated: (entity, type) => {  // Optional: callback after creation
    console.log('Entity created:', entity)
  },
  onTimelineEntry: (entry) => {  // Optional: callback for timeline entry
    console.log('Timeline entry:', entry)
  }
})

// Result includes:
// - entity: The generated entity
// - newAttributes: Attributes discovered during generation
// - timing: Performance metrics
// - debugData: LLM prompts and responses
// - timeline: Updated timeline array
// - timelineEntry: The timeline entry that was created
```

**What it handles automatically**:
- Entity generation (calls appropriate `create*` function)
- Timeline context setup
- Timeline entry creation
- Entity storage (if `entityStorage` provided)
- Entity history tracking (if `entityStorage` provided)

**When NOT to use**: For initial game generation during setup (use orchestrator services directly).

#### getNextEntityId()

**Location**: `src/services/entity-generation/categories.ts`

**Purpose**: Generates standardized entity IDs with auto-incrementing counters.

**When to use**: Always use this for entity IDs, never generate IDs manually.

```typescript
import { getNextEntityId } from '../services/entity-generation/categories'

// Generate ID for item
const itemId = getNextEntityId('item', 'weapon', 'Sword')
// Returns: "ite_sword_wea_001"

// Generate ID for NPC
const npcId = getNextEntityId('npc', 'merchant', 'Hans the Blacksmith')
// Returns: "npc_hans_the_blacksmith_mer_001"

// Generate ID for location
const locationId = getNextEntityId('location', 'town', 'Medieval Village')
// Returns: "loc_medieval_village_tow_001"
```

**ID Format**: `<typePrefix>_<sanitizedName>_<categoryPrefix>_<counter>`
- Type prefix: `ite` (item), `npc` (npc), `loc` (location)
- Category prefix: First 3 letters of category (e.g., `wea` for weapon)
- Counter: Auto-incrementing, zero-padded to 3 digits

**Important**: This function maintains counters internally. Always use it to ensure no ID collisions.

#### cleanJsonResponse()

**Location**: `src/services/entity-generation/item-generation.ts` (and similar in other generation files)

**Purpose**: Cleans LLM JSON responses that may contain markdown code blocks.

**When to use**: Always use this when parsing JSON from LLM responses.

```typescript
// Copy this function to your service if needed
function cleanJsonResponse(text: string): string {
  let cleaned = text.trim()
  
  // Remove markdown code blocks if present
  if (cleaned.startsWith('```json')) {
    cleaned = cleaned.substring(7)
  } else if (cleaned.startsWith('```')) {
    cleaned = cleaned.substring(3)
  }
  
  // Remove ``` at end
  if (cleaned.endsWith('```')) {
    cleaned = cleaned.substring(0, cleaned.length - 3)
  }
  
  return cleaned.trim()
}

// Usage
const response = await fetch(endpoint, { ... })
const json = await response.json()
const cleaned = cleanJsonResponse(json.text)  // Remove ```json markers
const data = JSON.parse(cleaned)
```

**Why it's needed**: LLMs sometimes wrap JSON in markdown code blocks, causing parsing to fail.

#### addNewAttributesToLibrary()

**Location**: `src/services/entity-generation/item-generation.ts` (and similar in other generation files)

**Purpose**: Adds newly discovered attributes to the gameRules attribute library.

**When to use**: After entity generation, if `result.newAttributes` contains new attributes.

```typescript
// Copy this function pattern to your service
function addNewAttributesToLibrary(
  newAttributes: Record<string, Attribute & { category: string }>,
  gameRules: GameRules
): void {
  Object.entries(newAttributes).forEach(([attrName, attr]) => {
    const category = gameRules.itemCategories.find(cat => cat.name === attr.category)
    if (category) {
      // Check if attribute already exists
      const existing = category.attributes.find(a => a.name === attrName)
      if (!existing) {
        // Add to category's attribute library
        category.attributes.push({
          name: attrName,
          type: attr.type,
          description: attr.description,
          reference: attr.reference
        })
        console.log(`✅ Added new attribute "${attrName}" to ${attr.category} category`)
      }
    }
  })
}

// Usage after generation
const result = await createItem('Create a fire sword', gameRules, region, x, y)

if (result.newAttributes && Object.keys(result.newAttributes).length > 0) {
  addNewAttributesToLibrary(result.newAttributes, gameRules)
  // Now future generations can use these attributes
}
```

**Why it's important**: Keeps the attribute library up to date, ensuring consistency across entity generations.

#### Core Generation Functions

**Location**: `src/services/entity-generation/`

**Functions**: `createItem()`, `createNpc()`, `createLocation()`, `createRegion()`

**When to use**: 
- During initial game generation (orchestrator)
- When you need generation without timeline/storage integration
- When using `generateEntityWithContext()` internally (don't call directly)

**When NOT to use**: For runtime entity generation during gameplay (use `generateEntityWithContext()` instead).

```typescript
import { createItem } from '../services/entity-generation'

// Direct generation (no timeline/storage integration)
const result = await createItem(
  'Create a sword',
  gameRules,
  'region_001',
  0,
  0
)
// You must manually:
// - Add to storage
// - Update timeline
// - Track entity history
```

#### Higher-Level Generation Helpers

**Location**: `src/services/entity-generation/index.ts`

**Functions**: `generateAndAddItem()`, `generateAndAddNPC()`, `generateAndAddLocation()`, `generateAndAddRegion()`

**When to use**: When you need to generate and add to storage in one call, but don't need timeline integration.

```typescript
import { generateAndAddItem } from '../services/entity-generation'

const result = await generateAndAddItem(
  'Create a sword',
  gameRules,
  'region_001',
  0,
  0,
  entityStorage  // Automatically adds to storage
)
// Note: Still need to update timeline manually if needed
```

**When NOT to use**: For runtime generation during gameplay (use `generateEntityWithContext()` for full integration).

#### Schema, Category, and Model Constants

**Location**: 
- Schemas: `src/services/entity-generation/core.ts`
- Categories: `src/services/entity-generation/categories.ts`
- Models: `src/services/entity-generation/core.ts`

**Purpose**: Standard constants that should be reused, never redefined.

**When to use**: Always import and reuse these constants.

```typescript
// Import schemas
import { 
  ITEM_SCHEMA, 
  NPC_SCHEMA, 
  LOCATION_SCHEMA 
} from '../services/entity-generation/core'

// Import categories
import { 
  ITEM_CATEGORIES,
  NPC_CATEGORIES,
  LOCATION_CATEGORIES
} from '../services/entity-generation/categories'

// Import models
import { 
  STRUCTURED_FLASH_LITE_MODEL,
  STRUCTURED_IMAGE_MODEL,
  STRUCTURED_API_BASE_URL
} from '../services/entity-generation/core'

// Use them - never redefine
const schema = ITEM_SCHEMA
const model = STRUCTURED_FLASH_LITE_MODEL
const endpoint = `${STRUCTURED_API_BASE_URL}/${model}:generateContent?key=${API_KEY}`
```

**Why it's important**: Ensures consistency and makes updates easier (change once, affects everywhere).

### Entity Storage Helpers

#### Standard Storage Operations

**Location**: `src/context/EntityMemoryStorage.tsx`

**Functions**: `addEntity()`, `updateEntity()`, `removeEntity()`

**When to use**: Always use these for entity operations, never mutate storage directly.

```typescript
const { addEntity, updateEntity, removeEntity } = useEntityStorage()

// Add entity
addEntity(newItem, 'item')  // Automatically updates spatial index and registry

// Update entity
updateEntity(updatedItem, 'item', 'Player used item', 'player_action')
// Parameters: entity, type, changeReason (optional), changeSource (optional)

// Remove entity
removeEntity(itemId, 'item')  // Automatically removes from spatial index and registry
```

**What they handle automatically**:
- Spatial index updates
- Registry updates
- Entity history tracking (dev mode)
- Dev dashboard broadcasting (dev mode)

#### Standard Query Helpers

**Functions**: `getEntitiesAt()`, `getAllItemById()`, `getAllNPCById()`, `getAllLocationById()`, `getAllRegionById()`, `getRegionByCoordinates()`

**When to use**: Always use these for queries, never manually filter arrays.

```typescript
const { 
  getEntitiesAt,
  getAllItemById,
  getAllNPCById,
  getAllLocationById,
  getAllRegionById,
  getRegionByCoordinates
} = useEntityStorage()

// Spatial query (O(1) with spatial index)
const { items, npcs, locations } = getEntitiesAt('region_001', 45, -23)

// ID lookup (O(n) but standard way)
const item = getAllItemById('ite_sword_wea_001')
const npc = getAllNPCById('npc_merchant_mer_001')
const location = getAllLocationById('loc_town_tow_001')
const region = getAllRegionById('region_medieval_kingdom_001')

// Region by coordinates
const region = getRegionByCoordinates(2, 3)  // Grid coordinates
```

**Why use these**: 
- `getEntitiesAt()` is O(1) with spatial index (much faster than filtering)
- Standardized interface
- Consistent behavior

#### State Snapshot Helper

**Function**: `getStateSnapshot()`

**When to use**: For saving game state.

```typescript
const { getStateSnapshot } = useEntityStorage()

const snapshot = getStateSnapshot()
// Returns: { allItems, allLocations, allNPCs, allRegions }
// Use this for save game functionality
```

### Utility Functions

#### getRarityColor()

**Location**: `src/utils/rarity.utils.ts`

**Purpose**: Returns color for rarity level.

**When to use**: For UI components that display rarity.

```typescript
import { getRarityColor } from '../utils'

const color = getRarityColor('legendary')  // Returns color string
```

#### parseMarkdown()

**Location**: `src/utils/markdown.tsx`

**Purpose**: Parses markdown text to React nodes.

**When to use**: For displaying markdown text in components.

```typescript
import { parseMarkdown } from '../utils/markdown'

const markdownText = "**Bold** text with *italic*"
const nodes = parseMarkdown(markdownText)
// Returns: React.ReactNode[]

// Use in component
return <div>{parseMarkdown(markdownText)}</div>
```

### When to Use Which Helper

#### Entity Generation

- **Runtime generation (during gameplay)**: Use `generateEntityWithContext()`
- **Initial game generation**: Use `createItem()`, `createNpc()`, etc. directly (orchestrator)
- **Generate + add to storage (no timeline)**: Use `generateAndAddItem()`, etc.
- **Entity IDs**: Always use `getNextEntityId()`

#### Timeline Updates

- **In components**: Use `updateTimeline()` from GameStateContext
- **In services**: Use `logTimelineEvent()` (ensure context is set up)
- **Entity generation**: Use `generateEntityWithContext()` (handles timeline automatically)
- **Never**: Manually manipulate timeline array

#### Entity Storage

- **Add/Update/Remove**: Always use `addEntity()`, `updateEntity()`, `removeEntity()`
- **Spatial queries**: Use `getEntitiesAt()`
- **ID lookups**: Use `getAllItemById()`, etc.
- **Save games**: Use `getStateSnapshot()`
- **Never**: Manually mutate storage arrays or spatial index

#### JSON Parsing

- **LLM responses**: Always use `cleanJsonResponse()`
- **Regular JSON**: Use standard `JSON.parse()`

#### Constants

- **Schemas/Categories/Models**: Always import from `core.ts` and `categories.ts`
- **Never**: Redefine constants

## Type Safety

### Always Update Types First

1. **Define types** in `src/types/`
2. **Export from** `src/types/index.ts`
3. **Import in components/services**

### Type Checking

Ensure TypeScript compilation succeeds:

```bash
npm run build
```

This will catch type errors before runtime.

### Common Type Patterns

```typescript
// Entity IDs follow pattern
type ItemId = `ite_${string}_${string}_${string}`

// Slots store IDs
type SlotId = string | null

// Coordinates
interface Coordinates {
  region: string
  x: number
  y: number
}
```

## Testing Considerations

### What to Test

1. **State Updates**: Do entities update correctly in both spatial index and registries?
2. **Context Dependencies**: Does your component work with correct context nesting?
3. **Entity Operations**: Do add/update/remove operations maintain consistency?
4. **Player Actions**: Do player interactions update state correctly?

### Manual Testing Checklist

- [ ] Component renders without errors
- [ ] Context hooks return expected data
- [ ] State updates persist correctly
- [ ] Entity operations maintain spatial index
- [ ] Dev dashboard shows changes (dev mode)
- [ ] TypeScript compilation succeeds

### Testing Entity Updates

```typescript
// Test that spatial index stays consistent
const { addEntity, getEntitiesAt } = useEntityStorage()

const item = createTestItem({ region: 'region_001', x: 10, y: 20 })
addEntity(item, 'item')

const { items } = getEntitiesAt('region_001', 10, 20)
expect(items).toContainEqual(item)  // Should be in spatial index
```

## Integration Points

### Context Provider Order

**Critical**: Providers must nest in this order:

```typescript
<GameStateProvider>
  <EntityStorageProvider>
    <PlayerUIProvider>
      {/* Your components */}
    </PlayerUIProvider>
  </EntityStorageProvider>
</GameStateProvider>
```

### Entity Operations

Always use context methods:

```typescript
// ✅ CORRECT
const { updateEntity } = useEntityStorage()
updateEntity(updatedItem, 'item')

// ❌ WRONG
item.name = 'New Name'  // Direct mutation breaks spatial index
```

### Slot System

Remember slots store IDs:

```typescript
// ✅ CORRECT
inventorySlots['inv_slot_1'] = item.id
const item = getItemInSlot('inv_slot_1')

// ❌ WRONG
inventorySlots['inv_slot_1'] = item  // Don't store objects
```

## Common Implementation Patterns

### Pattern 1: Displaying Entities at Location

```typescript
const { getEntitiesAt } = useEntityStorage()
const { currentLocation } = usePlayerUI()

const { items, npcs } = getEntitiesAt(
  currentLocation.region,
  currentLocation.x,
  currentLocation.y
)

return (
  <div>
    {items.map(item => <ItemCard key={item.id} item={item} />)}
    {npcs.map(npc => <NPCCard key={npc.id} npc={npc} />)}
  </div>
)
```

### Pattern 2: Player Interaction

```typescript
const { takeItem, interactableItems } = usePlayerUI()

function handleTakeItem(item: Item) {
  takeItem(item)  // Handles coordinate update + slot assignment
}
```

### Pattern 3: Updating Entity Attributes

```typescript
const { getAllItemById, updateEntity } = useEntityStorage()

function reduceDurability(itemId: string, damage: number) {
  const item = getAllItemById(itemId)
  if (!item) return
  
  const durability = item.own_attributes?.durability
  if (!durability) return
  
  const updated = {
    ...item,
    own_attributes: {
      ...item.own_attributes,
      durability: {
        ...durability,
        value: Math.max(0, durability.value - damage)
      }
    }
  }
  
  updateEntity(updated, 'item')
}
```

### Pattern 4: Conditionally Rendering Based on State

```typescript
const { gameState } = useGameState()

if (gameState !== 'playing') {
  return <CharacterCreationScreen />
}

return <GameUI />
```

## Debugging Tips

### Check Context Availability

```typescript
try {
  const context = usePlayerUI()
  // Use context
} catch (error) {
  console.error('Context not available - check provider nesting')
}
```

### Inspect State in Dev Dashboard

In dev mode, open dev dashboard (`/dev-dashboard`) to see:
- All entities in storage
- Entity change history
- Current game state
- Player UI state

### Console Logging

```typescript
const { allItems } = useEntityStorage()
console.log('Items in storage:', allItems.length)
console.log('Items at location:', getEntitiesAt(region, x, y))
```

## Checklist for New Features

- [ ] Created component in appropriate folder
- [ ] Used correct context(s)
- [ ] Updated types if adding fields
- [ ] Integrated into App.tsx
- [ ] TypeScript compilation succeeds
- [ ] State updates use context methods (`addEntity`, `updateEntity`, `removeEntity`)
- [ ] Timeline updates use `logTimelineEvent()` or `updateTimeline()`
- [ ] Entity generation uses `generateEntityWithContext()` (for runtime) or `create*()` (for initial)
- [ ] Entity IDs use `getNextEntityId()`
- [ ] JSON parsing uses `cleanJsonResponse()` (for LLM responses)
- [ ] Discovered attributes added to library (if applicable)
- [ ] Constants imported from `core.ts` and `categories.ts` (not redefined)
- [ ] Storage queries use standard helpers (`getEntitiesAt`, `getAllItemById`, etc.)
- [ ] Spatial index maintained (if applicable)
- [ ] Dev dashboard shows changes (dev mode)
- [ ] Manual testing completed

## Getting Help

If you're stuck:

1. **Review existing patterns**: Look at similar components in the codebase
2. **Check documentation**: Review ARCHITECTURE.md and other docs
3. **Examine context implementations**: See how existing contexts are structured
4. **Test in isolation**: Create a simple test component first

## Data Flow Considerations for New Features

### Where to Hook Into Data Flow

#### Adding Features That Modify Entities

**Flow**:
```
Component Action
    ↓
PlayerUIContext method (if player-facing)
    OR
Direct EntityMemoryStorage call (if system-level)
    ↓
EntityMemoryStorage.updateEntity()
    ├─→ Updates registry
    ├─→ Updates spatial index
    └─→ Broadcasts change (dev mode)
    ↓
Components re-render with updated data
```

**Implementation**:
- Use existing context methods when possible
- Add new methods to context if needed
- Always maintain spatial index consistency

#### Adding Features That Display Data

**Flow**:
```
Component renders
    ↓
Calls context hook (usePlayerUI, useEntityStorage, etc.)
    ↓
Context computes/retrieves data
    ↓
Component receives data
    ↓
Component renders UI
```

**Implementation**:
- Derive data in render, don't store in component state
- Use context methods for queries
- Memoize expensive computations

#### Adding Features That Generate New Content

**Flow**:
```
User triggers generation
    ↓
Component calls generateEntityWithContext()
    ├─→ Sets up timeline context
    ├─→ Calls createItem()/createNpc()/etc.
    ├─→ Creates timeline entry
    ├─→ Adds to EntityStorage (if provided)
    └─→ Returns generated entity
    ↓
System indexes/processes new data
    ↓
Components re-render
```

**Implementation**:
- Use `generateEntityWithContext()` for runtime entity generation
- Handles timeline, storage, and history tracking automatically
- For initial game generation, use orchestrator services directly
- Components handle UI and user interaction

### Breaking Change Prevention Guidelines

1. **Type Extensions**: Always add optional fields
2. **Method Extensions**: Add new methods, don't change signatures
3. **Context Extensions**: Add new state/actions, don't remove existing
4. **Service Extensions**: Add optional parameters, use overloads
5. **Schema Extensions**: Add optional properties, don't add to required

See `docs/COMMON-PITFALLS.md` for things to avoid, `docs/SERVICES.md` for service layer patterns, and `docs/DATA-FLOW.md` for comprehensive data flow documentation.

