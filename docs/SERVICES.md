# Service Layer Documentation

This document explains the service layer architecture, how services work, and how to extend them.

## Service Architecture

Services in the Lost World codebase are **stateless modules** that handle business logic and external API integration:

```
src/services/
├── entity-generation/    # AI-powered entity creation
└── game-orchestrator/    # Game configuration and setup
```

## Entity Generation Service

**Location**: `src/services/entity-generation/`

### Overview

The entity generation service uses Google Gemini AI models to create game entities (Items, NPCs, Locations, Regions) with:
- Structured JSON metadata
- Dynamic attributes with full metadata
- AI-generated images

### Models Used

The service uses three Gemini models:

1. **`gemini-2.5-pro`**: Complex reasoning (game configuration)
2. **`gemini-2.5-flash-lite`**: Fast JSON generation (entity metadata, attributes)
3. **`gemini-2.5-flash-image`**: Image generation (Nano Banana)

**API Endpoint**: `https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent`

### Configuration

**Location**: `src/config/gemini.config.ts`

```typescript
export const GEMINI_CONFIG = {
  models: {
    pro: 'gemini-2.5-pro',
    flashLite: 'gemini-2.5-flash-lite',
    flashImage: 'gemini-2.5-flash-image',
  },
  apiBase: 'https://generativelanguage.googleapis.com/v1beta/models',
}

export const getApiKey = (): string => {
  const key = import.meta.env.VITE_GEMINI_API_KEY
  if (!key) {
    throw new Error('VITE_GEMINI_API_KEY not found in environment variables')
  }
  return key
}
```

**Environment Variable**: `VITE_GEMINI_API_KEY` in `.env` file

### Core Generation Functions

#### `createItem(prompt, gameRules, region, x, y)`

Creates a complete item with attributes and image.

```typescript
import { createItem } from './services/entity-generation'

const result = await createItem(
  'Create a tournament sword',
  gameRules,
  'region_medieval_kingdom_001',
  450,
  -123
)

// Result structure
const { entity, newAttributes, timing, debugData } = result
```

**Returns**:
- `entity`: Complete Item with image and attributes
- `newAttributes`: Attributes discovered during generation (auto-learned)
- `timing`: Performance metrics
- `debugData`: LLM prompts and responses (for debugging)

#### `createNpc(prompt, gameRules, region, x, y)`

Similar to `createItem`, but generates NPCs with conversation history support.

#### `createLocation(prompt, gameRules, region, x, y)`

Generates locations with themes and biomes.

#### `createRegion(prompt, gameRules, regionX, regionY)`

Generates regions (simple structure, no attributes/images).

### Generation Process

Each entity goes through a **3-step parallel process**:

1. **Step 1: Base JSON** (Sequential)
   - Model: `gemini-2.5-flash-lite`
   - Generates: `name`, `rarity`, `category`, `description`
   - Uses structured output with JSON schema

2. **Step 2: Attributes** (Parallel with Step 3)
   - Model: `gemini-2.5-flash-lite`
   - Generates: `own_attributes` with full metadata
   - Uses gameRules category attribute libraries

3. **Step 3: Image** (Parallel with Step 2)
   - Model: `gemini-2.5-flash-image`
   - Generates: Base64-encoded PNG image
   - Uses description from Step 1

**Performance**: Steps 2 and 3 run in parallel, reducing total time by 30-40%.

### Attribute System

Attributes include full metadata:

```typescript
{
  durability: {
    value: 75,
    type: 'integer',
    description: 'Item durability/condition',
    reference: '0=broken, 50=worn, 100=pristine'
  }
}
```

**Automatic Learning**: New attributes discovered during generation are automatically added to the gameRules category library for consistency in future generations.

### ID Generation

IDs are automatically generated with semantic structure:

**Format**: `<typePrefix>_<sanitizedName>_<categoryPrefix>_<counter>`

**Examples**:
- Item weapon: `ite_sword_wea_001`, `ite_sword_wea_002`
- NPC merchant: `npc_merchant_mer_001`
- Location town: `loc_village_tow_001`

**Type Prefixes**:
- Items: `ite_`
- NPCs: `npc_`
- Locations: `loc_`
- Regions: `region_` (direct, no category prefix)

### Category System

Categories are defined in `GameRules`:

```typescript
interface GameRules {
  itemCategories: Array<{
    name: string
    attributes: Array<{
      name: string
      type: 'integer' | 'number' | 'string' | 'boolean' | 'array'
      description: string
      reference: string
    }>
  }>
  // ... npcCategories, locationCategories
}
```

Categories are generated by the orchestrator based on historical period and genre, ensuring historically accurate entity categories.

### Usage Example

```typescript
import { createItem, type GameRules } from './services/entity-generation'

const gameRules: GameRules = {
  artStyle: 'historical illustration',
  genre: 'exploration',
  historicalPeriod: 'Medieval Europe 1200s',
  itemCategories: [
    {
      name: 'weapon',
      attributes: [
        {
          name: 'damage',
          type: 'integer',
          description: 'Damage dealt in combat',
          reference: '10=dagger, 40=sword, 80=greatsword, 100=legendary'
        }
      ]
    }
  ],
  npcCategories: [],
  locationCategories: []
}

const result = await createItem(
  'Create a legendary fire sword',
  gameRules,
  'region_medieval_kingdom_001',
  50,
  -20
)

const { entity, newAttributes } = result
console.log('Generated item:', entity)
console.log('New attributes found:', newAttributes)
```

### Files Structure

```
entity-generation/
├── index.ts              # Main exports
├── core.ts                # Core schemas and constants
├── types.ts               # Service-specific types
├── categories.ts           # Category definitions
├── item-generation.ts      # Item generation logic
├── npc-generation.ts        # NPC generation logic
├── location-generation.ts  # Location generation logic
├── region-generation.ts   # Region generation logic
└── README.md              # Detailed service documentation
```

## Game Orchestrator Service

**Location**: `src/services/game-orchestrator/`

### Overview

The orchestrator service generates initial game configuration and entities when a new game is created.

### Main Functions

#### `generateGameConfiguration(characterName, description, artStyle)`

Creates complete game configuration using Gemini 2.5 Pro.

```typescript
import { generateGameConfiguration } from './services/game-orchestrator'

const config = await generateGameConfiguration(
  'Alexander the Great',
  'A game about conquering regions and building an empire',
  'historical illustration'
)
```

**Returns**: `GameConfiguration` with:
- `gameRules`: Category definitions, historical period, genre, art style
- `scratchpad`: Comprehensive game design document (500-800 words)
- `playerStats`: Dynamic stat definitions
- `startingLocation`: Where player starts
- `entitiesToGenerate`: List of entities to create (regions, locations, NPCs, items)

#### `generateGameEntities(config)`

Generates all initial entities based on configuration.

```typescript
import { generateGameEntities } from './services/game-orchestrator'

const entities = await generateGameEntities(config)
```

**Returns**: `GeneratedEntities` with arrays of:
- `regions`: Region[]
- `locations`: Location[]
- `npcs`: NPC[]
- `items`: Item[]

**Process**:
1. Generates regions (parallel)
2. Generates locations (parallel, assigned to regions)
3. Generates NPCs (parallel, assigned to locations)
4. Generates items (parallel, assigned to locations)

#### `createPlayer(characterName, description, playerStats, gameRules, startingLocation)`

Creates player character.

```typescript
import { createPlayer } from './services/game-orchestrator'

const player = await createPlayer(
  characterName,
  description,
  config.playerStats,
  config.gameRules,
  config.startingLocation
)
```

**Returns**: `PlayerCharacter` with:
- `name`: Character name
- `description`: Character description
- `stats`: PlayerStats (dynamic stats from config)
- `status`: PlayerStatus (health, energy)
- `startingLocation`: Location ID string (`"region:x:y"`)

### Configuration Schema

The orchestrator uses a strict schema (`GAME_CONFIGURATION_SCHEMA`) to ensure valid game configurations.

**See**: `src/services/game-orchestrator/types.ts` for full schema definition.

### Files Structure

```
game-orchestrator/
├── index.ts              # Main exports
├── types.ts              # Type definitions and schema
├── configurator.ts        # Game configuration generation
├── player-creation.ts     # Player character creation
└── seed-generator.ts      # Seed file generation (optional)
```

## API Integration

### Google Gemini API

All services use the Google Generative Language API.

**Base URL**: `https://generativelanguage.googleapis.com/v1beta/models`

**Authentication**: API key via `VITE_GEMINI_API_KEY` environment variable

**Request Format**:
```typescript
const endpoint = `${API_BASE_URL}/${MODEL}:generateContent?key=${API_KEY}`

const response = await fetch(endpoint, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    contents: [{
      parts: [{ text: prompt }]
    }],
    generationConfig: {
      response_mime_type: 'application/json',
      response_schema: schema  // For structured output
    }
  })
})
```

### Structured Output

For JSON generation, use structured output:

```typescript
generationConfig: {
  response_mime_type: 'application/json',
  response_schema: ITEM_SCHEMA  // JSON Schema definition
}
```

### Image Generation

For image generation, use `gemini-2.5-flash-image`:

```typescript
const response = await fetch(
  `${API_BASE_URL}/${IMAGE_MODEL}:generateContent?key=${API_KEY}`,
  {
    method: 'POST',
    body: JSON.stringify({
      contents: [{
        parts: [{ text: imagePrompt }]
      }]
    })
  }
)

// Response contains base64-encoded PNG image
const imageBase64 = response.data[0].content.parts[0].text
```

## Extending Services

### Adding a New Entity Generation Function

1. **Create generation file**:
   ```typescript
   // src/services/entity-generation/quest-generation.ts
   
   import { generateStructuredJSON, generateImageFromDescription } from './core'
   
   export async function createQuest(
     prompt: string,
     gameRules: GameRules
   ): Promise<GenerationResult<Quest>> {
     // Implementation
   }
   ```

2. **Define schema**:
   ```typescript
   // src/services/entity-generation/core.ts
   export const QUEST_SCHEMA = {
     type: 'object',
     properties: {
       name: { type: 'string' },
       // ... other properties
     },
     required: ['name', /* ... */]
   }
   ```

3. **Export from index**:
   ```typescript
   // src/services/entity-generation/index.ts
   export { createQuest } from './quest-generation'
   ```

4. **Update types**:
   ```typescript
   // src/types/quest.types.ts
   export interface Quest {
     // ... structure
   }
   ```

### Adding New API Integration

1. **Create service module**:
   ```typescript
   // src/services/custom-service/index.ts
   
   import { getApiKey } from '../../config/gemini.config'
   
   export async function customFunction() {
     const API_KEY = getApiKey()
     const endpoint = `${API_BASE_URL}/${MODEL}:generateContent?key=${API_KEY}`
     
     // API call
   }
   ```

2. **Follow error handling patterns**:
   ```typescript
   try {
     const response = await fetch(endpoint, { ... })
     if (!response.ok) {
       throw new Error(`API error: ${response.status}`)
     }
     return await response.json()
   } catch (error) {
     console.error('Service error:', error)
     throw error
   }
   ```

## Best Practices

1. **Stateless Services**: Services should not maintain internal state
2. **Error Handling**: Always handle API errors gracefully
3. **Type Safety**: Use TypeScript types for all inputs/outputs
4. **Performance**: Use parallel execution when possible
5. **Configuration**: Centralize API configuration in `gemini.config.ts`
6. **Documentation**: Document function signatures and return types

## Testing Services

### Manual Testing

Use the test interfaces:

- **Entity Generation**: `src/services/entity-generation/test.html`
- **Orchestrator**: `__tests__/game-configurator/dashboard.html`

### Service Testing Pattern

```typescript
// Example test
import { createItem } from './services/entity-generation'

const gameRules = {
  // ... test game rules
}

const result = await createItem(
  'Create a test sword',
  gameRules,
  'region_test_001',
  0,
  0
)

console.assert(result.entity !== undefined, 'Entity should be generated')
console.assert(result.entity.image_url !== undefined, 'Entity should have image')
```

## Common Patterns

### Parallel Generation

```typescript
// Generate multiple entities in parallel
const [item1, item2, item3] = await Promise.all([
  createItem(prompt1, gameRules, region, x1, y1),
  createItem(prompt2, gameRules, region, x2, y2),
  createItem(prompt3, gameRules, region, x3, y3)
])
```

### Sequential with Dependencies

```typescript
// Generate region first, then entities in it
const region = await createRegion(prompt, gameRules, 2, 3)
const location = await createLocation(
  prompt,
  gameRules,
  region.id,
  0,
  0
)
```

### Error Handling

```typescript
try {
  const result = await createItem(prompt, gameRules, region, x, y)
  // Use result
} catch (error) {
  console.error('Generation failed:', error)
  // Handle error (show message, retry, etc.)
}
```

## Service Dependencies

**Services depend on**:
- `config/gemini.config.ts`: API configuration
- `types/`: Type definitions
- External: Google Gemini API

**Services are used by**:
- `context/GameStateContext.tsx`: Calls orchestrator
- Components: Can call entity generation directly (rare)

See `src/services/entity-generation/README.md` for detailed entity generation documentation.

