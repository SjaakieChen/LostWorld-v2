# Service Layer Documentation

This document explains the service layer architecture, how services work, and how to extend them.

## Service Architecture

Services in the Lost World codebase are **stateless modules** that handle business logic and external API integration:

```
src/services/
├── entity-generation/    # AI-powered entity creation
└── game-orchestrator/    # Game configuration and setup
```

## Entity Generation Service

**Location**: `src/services/entity-generation/`

### Overview

The entity generation service uses Google Gemini AI models to create game entities (Items, NPCs, Locations, Regions) with:
- Structured JSON metadata
- Dynamic attributes with full metadata
- AI-generated images

### Models Used

The service uses three Gemini models:

1. **`gemini-2.5-pro`**: Complex reasoning (game configuration)
2. **`gemini-2.5-flash-lite`**: Fast JSON generation (entity metadata, attributes)
3. **`gemini-2.5-flash-image`**: Image generation (Nano Banana)

**API Endpoint**: `https://generativelanguage.googleapis.com/v1beta/models/{model}:generateContent`

### Configuration

**Location**: `src/config/gemini.config.ts`

```typescript
export const GEMINI_CONFIG = {
  models: {
    pro: 'gemini-2.5-pro',
    flashLite: 'gemini-2.5-flash-lite',
    flashImage: 'gemini-2.5-flash-image',
  },
  apiBase: 'https://generativelanguage.googleapis.com/v1beta/models',
}

export const getApiKey = (): string => {
  const key = import.meta.env.VITE_GEMINI_API_KEY
  if (!key) {
    throw new Error('VITE_GEMINI_API_KEY not found in environment variables')
  }
  return key
}
```

**Environment Variable**: `VITE_GEMINI_API_KEY` in `.env` file

### Core Generation Functions

#### `createItem(prompt, gameRules, region, x, y)`

Creates a complete item with attributes and image.

```typescript
import { createItem } from './services/entity-generation'

const result = await createItem(
  'Create a tournament sword',
  gameRules,
  'region_medieval_kingdom_001',
  450,
  -123
)

// Result structure
const { entity, newAttributes, timing, debugData } = result
```

**Returns**:
- `entity`: Complete Item with image and attributes
- `newAttributes`: Attributes discovered during generation (auto-learned)
- `timing`: Performance metrics
- `debugData`: LLM prompts and responses (for debugging)

#### `createNpc(prompt, gameRules, region, x, y)`

Similar to `createItem`, but generates NPCs with conversation history support.

#### `createLocation(prompt, gameRules, region, x, y)`

Generates locations with themes and biomes.

#### `createRegion(prompt, gameRules, regionX, regionY)`

Generates regions (simple structure, no attributes/images).

### Generation Process

Each entity goes through a **3-step parallel process**:

1. **Step 1: Base JSON** (Sequential)
   - Model: `gemini-2.5-flash-lite`
   - Generates: `name`, `rarity`, `category`, `description`
   - Uses structured output with JSON schema

2. **Step 2: Attributes** (Parallel with Step 3)
   - Model: `gemini-2.5-flash-lite`
   - Generates: `own_attributes` with full metadata
   - Uses gameRules category attribute libraries

3. **Step 3: Image** (Parallel with Step 2)
   - Model: `gemini-2.5-flash-image`
   - Generates: Base64-encoded PNG image
   - Uses description from Step 1

**Performance**: Steps 2 and 3 run in parallel, reducing total time by 30-40%.

### Attribute System

Attributes include full metadata:

```typescript
{
  durability: {
    value: 75,
    type: 'integer',
    description: 'Item durability/condition',
    reference: '0=broken, 50=worn, 100=pristine'
  }
}
```

**Automatic Learning**: New attributes discovered during generation are automatically added to the gameRules category library for consistency in future generations.

### ID Generation

IDs are automatically generated with semantic structure:

**Format**: `<typePrefix>_<sanitizedName>_<categoryPrefix>_<counter>`

**Examples**:
- Item weapon: `ite_sword_wea_001`, `ite_sword_wea_002`
- NPC merchant: `npc_merchant_mer_001`
- Location town: `loc_village_tow_001`

**Type Prefixes**:
- Items: `ite_`
- NPCs: `npc_`
- Locations: `loc_`
- Regions: `region_` (direct, no category prefix)

### Category System

Categories are defined in `GameRules`:

```typescript
interface GameRules {
  itemCategories: Array<{
    name: string
    attributes: Array<{
      name: string
      type: 'integer' | 'number' | 'string' | 'boolean' | 'array'
      description: string
      reference: string
    }>
  }>
  // ... npcCategories, locationCategories
}
```

Categories are generated by the orchestrator based on historical period and genre, ensuring historically accurate entity categories.

### Usage Example

```typescript
import { createItem, type GameRules } from './services/entity-generation'

const gameRules: GameRules = {
  artStyle: 'historical illustration',
  genre: 'exploration',
  historicalPeriod: 'Medieval Europe 1200s',
  itemCategories: [
    {
      name: 'weapon',
      attributes: [
        {
          name: 'damage',
          type: 'integer',
          description: 'Damage dealt in combat',
          reference: '10=dagger, 40=sword, 80=greatsword, 100=legendary'
        }
      ]
    }
  ],
  npcCategories: [],
  locationCategories: []
}

const result = await createItem(
  'Create a legendary fire sword',
  gameRules,
  'region_medieval_kingdom_001',
  50,
  -20
)

const { entity, newAttributes } = result
console.log('Generated item:', entity)
console.log('New attributes found:', newAttributes)
```

### Files Structure

```
entity-generation/
├── index.ts              # Main exports
├── core.ts                # Core schemas and constants
├── types.ts               # Service-specific types
├── categories.ts           # Category definitions
├── item-generation.ts      # Item generation logic
├── npc-generation.ts        # NPC generation logic
├── location-generation.ts  # Location generation logic
├── region-generation.ts   # Region generation logic
└── README.md              # Detailed service documentation
```

## Game Orchestrator Service

**Location**: `src/services/game-orchestrator/`

### Overview

The orchestrator service generates initial game configuration and entities when a new game is created.

### Main Functions

#### `generateGameConfiguration(characterName, description, artStyle)`

Creates complete game configuration using Gemini 2.5 Pro.

```typescript
import { generateGameConfiguration } from './services/game-orchestrator'

const config = await generateGameConfiguration(
  'Alexander the Great',
  'A game about conquering regions and building an empire',
  'historical illustration'
)
```

**Returns**: `GameConfiguration` with:
- `gameRules`: Category definitions, historical period, genre, art style
- `scratchpad`: Comprehensive game design document (500-800 words)
- `playerStats`: Dynamic stat definitions
- `startingLocation`: Where player starts
- `entitiesToGenerate`: List of entities to create (regions, locations, NPCs, items)

#### `generateGameEntities(config)`

Generates all initial entities based on configuration.

```typescript
import { generateGameEntities } from './services/game-orchestrator'

const entities = await generateGameEntities(config)
```

**Returns**: `GeneratedEntities` with arrays of:
- `regions`: Region[]
- `locations`: Location[]
- `npcs`: NPC[]
- `items`: Item[]

**Process**:
1. Generates regions (parallel)
2. Generates locations (parallel, assigned to regions)
3. Generates NPCs (parallel, assigned to locations)
4. Generates items (parallel, assigned to locations)

#### `createPlayer(characterName, description, playerStats, gameRules, startingLocation)`

Creates player character.

```typescript
import { createPlayer } from './services/game-orchestrator'

const player = await createPlayer(
  characterName,
  description,
  config.playerStats,
  config.gameRules,
  config.startingLocation
)
```

**Returns**: `PlayerCharacter` with:
- `name`: Character name
- `description`: Character description
- `stats`: PlayerStats (dynamic stats from config)
- `status`: PlayerStatus (health, energy)
- `startingLocation`: Location ID string (`"region:x:y"`)

### Configuration Schema

The orchestrator uses a strict schema (`GAME_CONFIGURATION_SCHEMA`) to ensure valid game configurations.

**See**: `src/services/game-orchestrator/types.ts` for full schema definition.

### Files Structure

```
game-orchestrator/
├── index.ts              # Main exports
├── types.ts              # Type definitions and schema
├── configurator.ts        # Game configuration generation
├── player-creation.ts     # Player character creation
└── seed-generator.ts      # Seed file generation (optional)
```

## API Integration

### Google Gemini API

All services use the Google Generative Language API.

**Base URL**: `https://generativelanguage.googleapis.com/v1beta/models`

**Authentication**: API key via `VITE_GEMINI_API_KEY` environment variable

**Request Format**:
```typescript
const endpoint = `${API_BASE_URL}/${MODEL}:generateContent?key=${API_KEY}`

const response = await fetch(endpoint, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
  },
  body: JSON.stringify({
    contents: [{
      parts: [{ text: prompt }]
    }],
    generationConfig: {
      response_mime_type: 'application/json',
      response_schema: schema  // For structured output
    }
  })
})
```

### Structured Output

For JSON generation, use structured output:

```typescript
generationConfig: {
  response_mime_type: 'application/json',
  response_schema: ITEM_SCHEMA  // JSON Schema definition
}
```

### Image Generation

For image generation, use `gemini-2.5-flash-image`:

```typescript
const response = await fetch(
  `${API_BASE_URL}/${IMAGE_MODEL}:generateContent?key=${API_KEY}`,
  {
    method: 'POST',
    body: JSON.stringify({
      contents: [{
        parts: [{ text: imagePrompt }]
      }]
    })
  }
)

// Response contains base64-encoded PNG image
const imageBase64 = response.data[0].content.parts[0].text
```

## Extending Services

### Adding a New Entity Generation Function

1. **Create generation file**:
   ```typescript
   // src/services/entity-generation/quest-generation.ts
   
   import { generateStructuredJSON, generateImageFromDescription } from './core'
   
   export async function createQuest(
     prompt: string,
     gameRules: GameRules
   ): Promise<GenerationResult<Quest>> {
     // Implementation
   }
   ```

2. **Define schema**:
   ```typescript
   // src/services/entity-generation/core.ts
   export const QUEST_SCHEMA = {
     type: 'object',
     properties: {
       name: { type: 'string' },
       // ... other properties
     },
     required: ['name', /* ... */]
   }
   ```

3. **Export from index**:
   ```typescript
   // src/services/entity-generation/index.ts
   export { createQuest } from './quest-generation'
   ```

4. **Update types**:
   ```typescript
   // src/types/quest.types.ts
   export interface Quest {
     // ... structure
   }
   ```

### Adding New API Integration

1. **Create service module**:
   ```typescript
   // src/services/custom-service/index.ts
   
   import { getApiKey } from '../../config/gemini.config'
   
   export async function customFunction() {
     const API_KEY = getApiKey()
     const endpoint = `${API_BASE_URL}/${MODEL}:generateContent?key=${API_KEY}`
     
     // API call
   }
   ```

2. **Follow error handling patterns**:
   ```typescript
   try {
     const response = await fetch(endpoint, { ... })
     if (!response.ok) {
       throw new Error(`API error: ${response.status}`)
     }
     return await response.json()
   } catch (error) {
     console.error('Service error:', error)
     throw error
   }
   ```

## Best Practices

1. **Stateless Services**: Services should not maintain internal state
2. **Error Handling**: Always handle API errors gracefully
3. **Type Safety**: Use TypeScript types for all inputs/outputs
4. **Performance**: Use parallel execution when possible
5. **Configuration**: Centralize API configuration in `gemini.config.ts`
6. **Documentation**: Document function signatures and return types

## Testing Services

### Manual Testing

Use the test interfaces:

- **Entity Generation**: `src/services/entity-generation/test.html`
- **Orchestrator**: `__tests__/game-configurator/dashboard.html`

### Service Testing Pattern

```typescript
// Example test
import { createItem } from './services/entity-generation'

const gameRules = {
  // ... test game rules
}

const result = await createItem(
  'Create a test sword',
  gameRules,
  'region_test_001',
  0,
  0
)

console.assert(result.entity !== undefined, 'Entity should be generated')
console.assert(result.entity.image_url !== undefined, 'Entity should have image')
```

## Common Patterns

### Parallel Generation

```typescript
// Generate multiple entities in parallel
const [item1, item2, item3] = await Promise.all([
  createItem(prompt1, gameRules, region, x1, y1),
  createItem(prompt2, gameRules, region, x2, y2),
  createItem(prompt3, gameRules, region, x3, y3)
])
```

### Sequential with Dependencies

```typescript
// Generate region first, then entities in it
const region = await createRegion(prompt, gameRules, 2, 3)
const location = await createLocation(
  prompt,
  gameRules,
  region.id,
  0,
  0
)
```

### Error Handling

```typescript
try {
  const result = await createItem(prompt, gameRules, region, x, y)
  // Use result
} catch (error) {
  console.error('Generation failed:', error)
  // Handle error (show message, retry, etc.)
}
```

## Service Dependencies

**Services depend on**:
- `config/gemini.config.ts`: API configuration
- `types/`: Type definitions
- External: Google Gemini API

**Services are used by**:
- `context/GameStateContext.tsx`: Calls orchestrator
- Components: Can call entity generation directly (rare)

See `src/services/entity-generation/README.md` for detailed entity generation documentation.

## Service Integration with Contexts

### How Services Flow Into Contexts

Services are **stateless** - they return data but don't store it. Contexts call services and handle storage.

#### Entity Generation Services → EntityMemoryStorage

**Flow**:
```
Service (createItem, createNpc, createLocation)
    ↓
Returns: GenerationResult<Entity>
    ↓
GameStateContext.startGeneration() calls service
    ↓
GameStateContext stores entities in generatedData.entities
    ↓
App.tsx passes entities to EntityStorageProvider as initialData
    ↓
EntityMemoryStorage.initializeStorage()
    ├─→ Builds spatial index from entities
    └─→ Populates registries (allItems, allLocations, etc.)
```

**Key Points**:
- Services generate complete entities with all fields
- Entities flow through GameStateContext first (for initial generation)
- EntityMemoryStorage indexes entities for runtime queries
- No transformation needed - services return ready-to-use entities

#### Orchestrator Services → GameStateContext

**Flow**:
```
GameStateContext.startGeneration()
    ↓
Calls generateGameConfiguration()
    ├─→ LLM generates config
    └─→ Returns: GameConfiguration
    ↓
Calls generateGameEntities(config)
    ├─→ Calls entity generation services
    └─→ Returns: GeneratedEntities
    ↓
Calls createPlayer(...)
    └─→ Returns: PlayerCharacter
    ↓
GameStateContext stores all in generatedData
    ├─→ config: GameConfiguration
    ├─→ entities: GeneratedEntities
    └─→ player: PlayerCharacter
```

**Key Points**:
- Orchestrator services coordinate multiple generation steps
- All generated data flows into GameStateContext
- GameStateContext is the source of truth for initial game state

#### Chatbot Services → Components

**Flow**:
```
Component (ChatInput)
    ↓
User types message
    ↓
Component calls DefaultChatAreaLLM.generateChatResponse()
    ├─→ Reads gameConfig from GameStateContext
    ├─→ Reads timeline from GameStateContext
    ├─→ Calls LLM API
    └─→ Returns: string (response)
    ↓
Component displays response
```

**Key Points**:
- Chatbot services are called directly from components
- They read context data but don't modify it
- They return data for immediate display (no storage needed)

### Service Data Transformation

#### Input Transformation

**Pattern**: User Input → Service Format

```typescript
// User provides simple description
const userInput = "Create a legendary sword"

// Service transforms to structured prompt
const prompt = `You are a historical game designer.
User Request: ${userInput}
Generate following schema...`

// Service calls LLM with structured prompt
const entity = await generateItemJSON(prompt, gameRules)
```

#### Output Transformation

**Pattern**: LLM Response → Entity Structure

```typescript
// LLM returns JSON
const llmResponse = {
  name: "Legendary Fire Sword",
  rarity: "legendary",
  visualDescription: "...",
  functionalDescription: "..."
}

// Service transforms to complete Entity
const entity: Item = {
  ...llmResponse,
  id: getNextEntityId('item', llmResponse.category, llmResponse.name),
  own_attributes: await generateAttributes(...),
  image_url: await generateImage(...),
  x: 450,
  y: -123,
  region: 'region_medieval_kingdom_001'
}
```

### Service → Context Integration Patterns

#### Pattern 1: Initial Generation

```typescript
// In GameStateContext.startGeneration()
const config = await generateGameConfiguration(...)
const entities = await generateGameEntities(config)
const player = await createPlayer(...)

// Store in context
setGeneratedData({ config, entities, player })
```

**Data Flow**:
- Services generate data
- Context stores data
- Context passes to child providers

#### Pattern 2: Runtime Generation

```typescript
// In component or context
const { addEntity } = useEntityStorage()

// Generate new entity at runtime
const result = await createItem(
  'Create a potion',
  gameRules,
  currentLocation.region,
  currentLocation.x,
  currentLocation.y
)

// Add to storage
addEntity(result.entity, 'item')
```

**Data Flow**:
- Component/Context calls service
- Service generates entity
- Context adds entity to storage
- System indexes entity

#### Pattern 3: Chatbot Interaction

```typescript
// In component
const { generatedData } = useGameState()

const response = await DefaultChatAreaLLM.generateChatResponse(
  userMessage,
  generatedData.config,
  generatedData.timeline,
  allowedTags
)

// Display response (no storage needed)
setMessages(prev => [...prev, { type: 'assistant', text: response }])
```

**Data Flow**:
- Component calls service with context data
- Service processes with LLM
- Component displays result (no storage)

### Breaking Change Prevention in Services

#### Adding Optional Parameters

```typescript
// ✅ SAFE: Adding optional parameter
export async function createItem(
  prompt: string,
  gameRules: GameRules,
  region: string,
  x: number,
  y: number,
  options?: ItemGenerationOptions  // New optional parameter
): Promise<GenerationResult<Item>>

// ❌ BREAKING: Changing required parameters
export async function createItem(
  prompt: string,
  gameRules: GameRules,
  region: string,
  x: number,
  y: number,
  options: ItemGenerationOptions  // Now required - BREAKS!
): Promise<GenerationResult<Item>>
```

#### Extending Return Types

```typescript
// ✅ SAFE: Adding optional fields to return type
interface GenerationResult<T> {
  entity: T
  newAttributes: Record<string, Attribute>
  timing: TimingInfo
  debugData: DebugInfo
  metadata?: GenerationMetadata  // New optional field
}

// ❌ BREAKING: Changing required fields
interface GenerationResult<T> {
  entity: T
  newAttributes: Record<string, Attribute>
  timing: TimingInfo
  debugData: DebugInfo  // Removing this breaks existing code!
}
```

## Service Data Flow Diagrams

### Entity Generation Service Flow

```
[Service Layer]
createItem(prompt, gameRules, region, x, y)
    ├─→ generateItemJSON()
    │   └─→ LLM (gemini-2.5-flash-lite)
    │       └─→ BaseEntityInfo
    │
    ├─→ generateItemAttributes() [PARALLEL]
    │   └─→ LLM (gemini-2.5-flash-lite)
    │       └─→ own_attributes
    │
    └─→ generateItemImage() [PARALLEL]
        └─→ LLM (gemini-2.5-flash-image)
            └─→ image_url
    ↓
Complete Entity
    ↓
[Context Layer]
GameStateContext stores in generatedData
    ↓
EntityMemoryStorage indexes entity
    ├─→ Adds to registry
    └─→ Adds to spatial index
```

### Orchestrator Service Flow

```
[Service Layer]
generateGameConfiguration(name, description, artStyle)
    └─→ LLM (gemini-2.5-pro)
        └─→ GameConfiguration {
              gameRules,
              theGuideScratchpad,
              theTimeline,
              entitiesToGenerate,
              ...
            }
    ↓
generateGameEntities(config)
    ├─→ For each region spec → createRegion()
    ├─→ For each location spec → createLocation()
    ├─→ For each NPC spec → createNpc()
    └─→ For each item spec → createItem()
    ↓
GeneratedEntities
    ↓
[Context Layer]
GameStateContext stores all
    ├─→ config: GameConfiguration
    ├─→ entities: GeneratedEntities
    └─→ player: PlayerCharacter
```

### Chatbot Service Flow

```
[Component Layer]
ChatInput component
    ↓
User types message
    ↓
[Service Layer]
DefaultChatAreaLLM.generateChatResponse()
    ├─→ Reads gameConfig from GameStateContext
    ├─→ Reads timeline from GameStateContext
    ├─→ Filters timeline by allowed tags
    ├─→ Calls LLM (gemini-2.5-flash)
    └─→ Returns: string (response)
    ↓
[Component Layer]
Component displays response
    └─→ No storage needed (ephemeral data)
```

## Service Integration Best Practices

1. **Services are Stateless**: Don't store state in services
2. **Return Complete Data**: Services should return ready-to-use data structures
3. **Handle Errors**: Services should throw descriptive errors
4. **Type Safety**: Use TypeScript types for all inputs/outputs
5. **Documentation**: Document function signatures and data transformations
6. **Integration Points**: Clearly document where services integrate with contexts

## See Also

- `docs/DATA-FLOW.md` - Comprehensive data flow documentation
- `docs/STATE-MANAGEMENT.md` - How contexts use service data
- `docs/IMPLEMENTING-FEATURES.md` - How to add new services

