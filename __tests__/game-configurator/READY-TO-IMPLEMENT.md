# Ready to Implement: Dashboard Integration

## ✅ Structure Verification Complete

All structures have been verified and are correct:

### GameRules Structure
- ✅ TypeScript interface matches JSON schema
- ✅ Orchestrator generates correct format
- ✅ Entity generation functions use dynamic categories
- ✅ Fallback to hardcoded categories works

### Environment Variables
- ✅ `.env` file setup is correct
- ✅ `VITE_GEMINI_API_KEY` is used throughout
- ✅ Vite will inject environment variables automatically

### Category System
- ✅ Dynamic categories generated by LLM
- ✅ Separate categories for items, NPCs, locations
- ✅ Each category has 2-3 starting attributes
- ✅ Attributes have type, description, and reference

## Implementation Plan

### Step 1: Setup Vite for Dashboard

**Create**: `vite.config.dashboard.ts`
```typescript
import { defineConfig } from 'vite'

export default defineConfig({
  root: '__tests__/game-configurator',
  server: {
    port: 3001
  },
  build: {
    outDir: 'dist'
  },
  resolve: {
    alias: {
      '@': '/src'
    }
  }
})
```

**Update**: `package.json`
```json
{
  "scripts": {
    "dashboard": "vite --config vite.config.dashboard.ts",
    "dashboard:build": "vite build --config vite.config.dashboard.ts"
  }
}
```

### Step 2: Update Dashboard TypeScript

**Replace mock with real API calls** in `dashboard.ts`:

```typescript
import { 
  generateGameConfiguration, 
  generateGameEntities,
  generateSeedFiles,
  type GameConfiguration,
  type GeneratedEntities
} from '../../src/services/game-orchestrator'

class GameConfiguratorDashboard {
  private config: GameConfiguration | null = null
  private entities: GeneratedEntities | null = null
  private seedFiles: any = null

  private async generateConfiguration() {
    const characterName = (document.getElementById('characterName') as HTMLInputElement)?.value
    const gameDescription = (document.getElementById('gameDescription') as HTMLTextAreaElement)?.value

    if (!characterName || !gameDescription) {
      this.showError('Please fill in both character name and game description')
      return
    }

    this.showLoading()
    this.hideError()
    this.hideResults()

    try {
      // STEP 1: Generate configuration with Gemini 2.5 Pro
      this.updateStatus('Generating game configuration with Gemini 2.5 Pro...')
      this.config = await generateGameConfiguration(characterName, gameDescription)
      
      console.log('Configuration generated:', this.config)
      this.displayConfiguration(this.config)
      
      // STEP 2: Generate entities
      this.updateStatus('Generating entities (this may take 5-10 minutes)...')
      this.entities = await generateGameEntities(this.config)
      
      console.log('Entities generated:', this.entities)
      this.displayGeneratedEntities(this.entities)
      
      // STEP 3: Generate seed files
      this.updateStatus('Generating seed files...')
      this.seedFiles = generateSeedFiles(this.entities, this.config)
      
      this.hideLoading()
      this.showResults()
      this.updateStatus('✅ Generation complete!')
      
    } catch (error: any) {
      console.error('Generation failed:', error)
      this.showError(`Generation failed: ${error.message}`)
      this.hideLoading()
    }
  }

  private updateStatus(message: string) {
    const statusElement = document.getElementById('statusMessage')
    if (statusElement) {
      statusElement.textContent = message
    }
    console.log(message)
  }
}
```

### Step 3: Add Progress UI to HTML

**Update**: `dashboard.html`

Add progress section after the loading state:

```html
<!-- Loading State -->
<div id="loadingState" class="loading-state hidden">
    <div class="spinner"></div>
    <p id="statusMessage" class="status-message">Generating...</p>
</div>
```

### Step 4: Update Display Functions

**Show real data** instead of mock:

```typescript
private displayConfiguration(config: GameConfiguration) {
  // Scratchpad (500-800 words)
  const scratchpadElement = document.getElementById('scratchpad')
  if (scratchpadElement) {
    scratchpadElement.textContent = config.scratchpad
  }

  // Game Rules
  const gameRulesElement = document.getElementById('gameRules')
  if (gameRulesElement) {
    const rulesText = `
Historical Period: ${config.gameRules.historicalPeriod}
Genre: ${config.gameRules.genre}
Art Style: ${config.gameRules.artStyle}

Categories (${Object.keys(config.gameRules.categories).length}):
${Object.entries(config.gameRules.categories).map(([name, data]) => {
  const attrCount = Object.keys(data.attributes).length
  return `- ${name} (${attrCount} attributes)`
}).join('\n')}

Detailed Categories:
${JSON.stringify(config.gameRules.categories, null, 2)}
    `.trim()
    gameRulesElement.textContent = rulesText
  }

  // Entities to Generate
  const entitiesElement = document.getElementById('entitiesToGenerate')
  if (entitiesElement) {
    const entitiesText = `
REGIONS (${config.entitiesToGenerate.regions.length}):
${config.entitiesToGenerate.regions.map(r => `- ${r.name} (${r.theme}, ${r.biome})`).join('\n')}

LOCATIONS (${config.entitiesToGenerate.locations.length}):
${config.entitiesToGenerate.locations.map(l => `- ${l.prompt.substring(0, 60)}... (${l.significance})`).join('\n')}

NPCS (${config.entitiesToGenerate.npcs.length}):
${config.entitiesToGenerate.npcs.map(n => `- ${n.prompt.substring(0, 60)}... (${n.significance})`).join('\n')}

ITEMS (${config.entitiesToGenerate.items.length}):
${config.entitiesToGenerate.items.map(i => `- ${i.prompt.substring(0, 60)}... (${i.significance})`).join('\n')}
    `.trim()
    entitiesElement.textContent = entitiesText
  }
}

private displayGeneratedEntities(entities: GeneratedEntities) {
  const generatedElement = document.getElementById('generatedEntities')
  if (generatedElement) {
    const entitiesText = `
GENERATED ENTITIES:
==================

REGIONS (${entities.regions.length}):
${entities.regions.map(r => `- ${r.name} (ID: ${r.id}) at (${r.regionX}, ${r.regionY})`).join('\n')}

LOCATIONS (${entities.locations.length}):
${entities.locations.map(l => `- ${l.name} (ID: ${l.id}, Category: ${l.category}, Rarity: ${l.rarity})`).join('\n')}

NPCS (${entities.npcs.length}):
${entities.npcs.map(n => `- ${n.name} (ID: ${n.id}, Category: ${n.category}, Rarity: ${n.rarity})`).join('\n')}

ITEMS (${entities.items.length}):
${entities.items.map(i => `- ${i.name} (ID: ${i.id}, Category: ${i.category}, Rarity: ${i.rarity})`).join('\n')}

All entities have been generated with:
- Unique IDs
- Dynamic categories from GameRules
- Appropriate attributes
- Historical accuracy
- Generated images (base64 encoded)
    `.trim()
    generatedElement.textContent = entitiesText
  }
}
```

### Step 5: Update Download Functions

**Use real seed files**:

```typescript
private downloadSeeds() {
  if (!this.seedFiles) {
    this.showError('No seed files available')
    return
  }

  // Download all seed files as separate files
  Object.entries(this.seedFiles).forEach(([filename, content]) => {
    const blob = new Blob([content as string], { 
      type: filename.endsWith('.json') ? 'application/json' : 'text/typescript' 
    })
    const url = URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = filename
    a.click()
    URL.revokeObjectURL(url)
  })
}
```

## Environment Setup

### Required .env File

Create `.env` in project root:
```
VITE_GEMINI_API_KEY=your_actual_gemini_api_key_here
```

### Verify API Key

The orchestrator will automatically use this key through:
```typescript
const key = import.meta.env.VITE_GEMINI_API_KEY
```

## Testing Checklist

After implementation, test with Marco Polo example:

### Configuration Generation
- [ ] Enter "Marco Polo" as character name
- [ ] Enter detailed description about 13th century exploration
- [ ] Click "Generate Game Configuration"
- [ ] Verify API call to Gemini 2.5 Pro succeeds
- [ ] Check scratchpad is 500-800 words
- [ ] Verify historical period has exact dates
- [ ] Check categories are genre-appropriate
- [ ] Verify regions use real names (Venice, Persian Empire, Yuan Dynasty China)

### Entity Generation
- [ ] Verify entity generation starts automatically
- [ ] Check progress updates appear
- [ ] Verify locations are generated with images
- [ ] Check NPCs are generated with attributes
- [ ] Verify items are generated correctly
- [ ] Confirm all entities use dynamic categories from GameRules

### Display & Download
- [ ] Scratchpad displays full text
- [ ] Categories show all attributes with references
- [ ] Generated entities show IDs, categories, rarities
- [ ] Download config JSON works
- [ ] Download scratchpad.txt works
- [ ] Download seed files works

### Error Handling
- [ ] Test with invalid API key
- [ ] Test with network error
- [ ] Verify error messages are clear
- [ ] Check retry logic works

## Expected Results

### Marco Polo Example Output

**Scratchpad**: 500-800 words including:
- Game title: "Marco Polo's Journey to the East (1271-1295 CE)"
- Detailed narrative arc with 5-7 plot points
- Core mechanics: trading, diplomacy, exploration, resource management
- What makes it fun: historical discovery, economic strategy, cultural exchange
- Historical accuracy notes

**GameRules**:
- Historical Period: "1271-1295 CE - Late Medieval Period, Yuan Dynasty China"
- Genre: "historical exploration and trading RPG"
- Art Style: "13th century manuscript illumination style"
- Categories: trade_good, document, tool, merchant, noble, guard, city, landmark, building

**Regions**:
- Venice (medieval Italian city-state)
- Persian Empire (Islamic golden age)
- Yuan Dynasty China (Mongol empire)

**Generated Entities**:
- 4-6 locations with real historical places
- 3-5 NPCs including Kublai Khan and Niccolo Polo
- 3-5 items including papal letter and trade goods
- All with appropriate categories and attributes

## Ready to Implement

All structures verified ✅
Plan is complete ✅
Environment setup documented ✅
Testing checklist prepared ✅

**Next step**: Implement the dashboard integration following this plan!
